{
	"entries":[
		{
		"date":"06/01/2015",
		"title":"Day 1",
		"text":"5:36pm, Day 1; feels like the end of the day. A few familiar things, but mostly not.<br><br>Worked with some basic code modifications and running an application on Twitter.<br>The process is mostly a fog, but I think that's partly because of its relative simplicity.<br>At least to the extent that we didn't write any code just made a few modifications,<br>and set up a lot of accounts to make the thing run.<br><br>Second lab was Git based. A little confusing in that there are multiple ways of doing<br>the same thing that seem instinctively to be unrelated. Apparently, there are also<br>different versions of essentially the same thing and some work while others don't<br>- i.e. an incorrect command prompt based on the lack (or maybe presence) of a security<br>certificate (or some such thing). A big part of the challenge of learning to code<br>seems to be understanding not simply the interconnectedness of the various components,<br>but also the multitude of ways the same task can be accomplished and choosing the best approach<br>for a given task.<br><br>Spent forever trying to add a simple text file to a GitHub repository with SourceTree. Ultimately,<br>the solution was simply to create a text file, and save it in the same directory as<br>the repository.<br><br>By 8pm the very basics of SourceTree are making sense.<br><br>Tired; satisfied."
		},
		{
		"date":"06/02/2015",
		"title":"Day 2",
		"text":"Second day. Overall more interesting, and more comfortable.<br>Less setting up of accounts, and more code writing. It's always<br>a fog trying to remember exactly what we've done. Spent a lot<br>of time playing with iPython Notebooks; tinkering with formatting<br>and output. First AOYO lab covered computing string length, adding<br>a string to a variable input for a combined print statement, returning<br>a specific term within a list, and stripping the first and last<br>terms from a list print list[1:-1].<br><br>Second lab dealt with condition execution: if, elif, else. Covered<br>comparison operators. TURN OFF TABS. Learned the importance of<br>indentation (nested decisions), capitalization. Covered one, two,<br>and multi-way decisions. Labs ranged from intuitive and satisfying<br>(if/else squirrel play given season) to extremely frustrating, and where<br>I'm still stuck evaluating a numbers relationship to a multiple of 10.<br>I have an idea that seems to be getting upended by rounding issues.<br>Probably need to use modulo. Very little experience with this as<br>an actual mathematical tool.<br><br>Need to dig a little more deeply into some of these less familiar concepts."
		},
		{
		"date":"06/03/2015",
		"title":"Day 3",
		"text":"Day 3, June 3, 2015<br><br>Partly a carry over from yesterday, but finished cleaning up<br>code late last night to determine whether or not a number is<br>equal to or with two digits of a multiple of ten. This required<br>the realization that the remainder (modulo) isn't simply a concept<br>for the fourth grade. Initially, I had divided my number input by<br>10 and realized the decimal place of the target numbers was always<br>.8, .9, 0, .1, or .2. Had code written relatively quickly to use<br>this pattern, but a rounded area somewhere within the machine prevented<br>it from working properly. Eventually, decided to make friends with<br>modulo, and the solution was relatively simple. The same pattern<br>remained the answer, but without the decimal points - i.e. 8, 9, 0, 1,<br>2. Ryan had worked on the decimal solution overnight, and found<br>\"import decimal from Decimal\" to be useful, though, it wasn't entirely<br>clear whether or not lingering issues remained.<br><br>Pared down script from late last night to validate the format of an email<br>address. I had a very bulky solution last night, and one that didn't<br>catch all errors. Used .split(\"@\") to separate mailbox from domain portions,<br>and len(emailSplit) to evaluate portions of the address in addition to<br>checking for the presence of \"@\", ensuring there were 2 list items in the<br>split, and checking for specific characters. The bulkiness of last night primarily<br>came from the method by which I was trying to exclude numbers from the first characters<br>position in the mailbox portion of the address. Ultimately, .isalpha() saved the day.<br><br>This morning's lecture covered functions. I understand the concept pretty well,<br>but their implication is trickier than it would seem. We started writing code<br>for a relatively tricky dice game that we invented. I feel like I need loops<br>to pare down this code. I have functions in place, but their guts still seem very<br>bulky. My approach to labs so far has been to get the inputs working as a set<br>up to easy access to the data later."
		},
		{
		"date":"06/04/2015",
		"title":"Day 4",
		"text":"Day 4, June 4, 2015<br>Spent all day with dice game; miles from being finished.<br>Was flying this morning, but flying with longhand code writing.<br>Inevitably, I hit a point where I couldn't continue. I'm now<br>struggling like crazy to think in functions and loops rather<br>than longhand logic."
		},
		{
		"date":"06/05/2015",
		"title":"Day 5",
		"text":"Day 5: June 5, 2015<br><br>A lot of progress today. Moving into late yesterday afternoon I<br>was struggling to see anything in terms of functions and loops.<br>Started understanding it before leaving yesterday, and actually<br>woke up at 1:30am with an idea about how to substantially shrink<br>my dice rolling function. Initially, I had established a separate<br>random number generator for each of the six die. While sleeping I<br>came up with:<br><br>from random import randit<br><br>def dieRoll(dieSelection):<br>roll=randit(1,dieSelection)<br>return roll<br><br>Spent all of today re-writing the dice program in functions and<br>loops that operate with a Player class object. Still using a little<br>longhand thinking in that I am taking player name input in one<br>function, then converting it to an object in another:<br><br>#get player names<br>def getNames(i):<br>playersList=[]<br>while len(playersList)<i:<br>input = raw_input(\"Player enter your name >\")<br>playersList.append(input)<br>return playersList<br><br>use playersList to create objects<br>def convertToObjects(pL):<br>playerObjects=[]<br>for i in pL:<br>player = Player(i)<br>playerObjects.append(player)<br>return playerObjects<br><br>Also, taking in number of players separately:<br><br>#get number of players<br>def numPlayers():<br> input = raw_input(\"Enter number of players >\")<br>input = int(input)<br>return input<br><br>Eventhough, all of these things could be done separately there is, for<br>now anyway, use for me in thinking about every aspect of the program<br>separately, and writing them as individual functions."
		},
		{
		"date":"06/08/2015",
		"title":"Day 6",
		"text":"Day 6, June 8, 2015<br>Starting to think I've over shot with my attempt to simplify my code writing. I've essentially banished all if/elif/else statements in exchange for functions and loops that I can't entirely figure out how to use. The logic is clear enough, and I'm getting the hang of scope and syntax, but I think ultimately the shorthand is unnecessarily short. It's left me stuck trying to do too many things that at this point are not intuitive at the expense of those things that are intuitive. Importantly, the intuitive things are usable which leaves the entire exercise creating more problems than not. It's obvious I need to find a balance"
		},
				{
		"date":"06/09/2015",
		"title":"Day 7",
		"text":"Day 7, June 9, 2015<br>Worked primarily on happy numbers today. A little on our game too, but was struggling a bit. Wrote a function to reply play again or declare game over. It's occurred to me that code is often more readable backwards. Even the problem solving process seems to work better in reverse - i.e. coding a function to process the ultimate solution, then a function for the process before, etc. Having realized that learning to see structure is my primary need should help me focus on how to better approach things moving forward. The analogy of a tree strikes me as particularly relevant where the tree and branches are the underlying data structure, and the fruit that would hang on the tree is the various bits of code. I can live without knowing what all of the fruit is or where it goes, but I have to learn to see the tree."
		}
	]
}